var __typeError = (msg) => {
  throw TypeError(msg);
};
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);

// src/index.ts
var EventEmitter = class {
  constructor(options) {
    this._listeners = /* @__PURE__ */ new Map();
    this._options = { debug: null };
    if (options) {
      this._options = options;
    }
    return this;
  }
  /**
   * Debug, uses 2 levels (info or error), provided for each method;
   * 
   * @param type 
   * @param v 
   * @param action 
   */
  debug(type, v, action) {
    if (this._options.debug) {
      if (type === "info" && this._options.debug === "all") {
        console.info(`%c ${action}`, "color:blue;", v);
      }
      if (type === "error" && (this._options.debug === "all" || this._options.debug === "error")) {
        console.info(`%c ${action}`, "color:red;", v);
      }
    }
  }
  /**
   * Emits value to subscribers by key;
   * 
   * @param key 
   * @param val 
   */
  emit(key, val) {
    try {
      const listenersOn = this._listeners.get(key);
      if (listenersOn == null ? void 0 : listenersOn.length) {
        listenersOn.forEach((l) => {
          this.debug("info", { l, key, val }, "emit");
          typeof l.next === "function" ? l.next(val) : l.error && l.error(new Error("method .next() must be a function"));
        });
      }
    } catch (e) {
      this.debug("error", e, "emit error");
    }
  }
  /**
   * Subscribe to all events with provided key (listener.on);
   * 
   * @param listener 
   * @returns
   */
  subscribe(listener) {
    try {
      if (this._listeners.has(listener.on)) {
        this._listeners.set(
          listener.on,
          [...this._listeners.get(listener.on), listener]
        );
      } else {
        this._listeners.set(listener.on, [listener]);
      }
      this.debug("info", { listeners: this._listeners }, "subscribe");
      return listener;
    } catch (e) {
      this.debug("error", e, "subscribe error");
      listener.error && listener.error(e);
      return listener;
    }
  }
  /**
   * Unsubscribe by subscriber referer
   * 
   * @param listener 
   */
  unsubscribe(listener) {
    try {
      const listenersOn = this._listeners.get(listener.on);
      if (listenersOn == null ? void 0 : listenersOn.length) {
        this._listeners.set(listener.on, listenersOn.filter((l) => l !== listener));
      }
      this.debug("info", { listeners: this._listeners }, "unsubscribe");
    } catch (e) {
      this.debug("error", e, "unsubscribe error");
      listener.error && listener.error(e);
    }
  }
  /**
   * Remove all subscribers for provided key
   * 
   * @param key 
   */
  unsubscribeAllKey(key) {
    try {
      this._listeners.delete(key);
    } catch (e) {
      this.debug("error", e, "unsubscribeAllKey error");
    }
  }
  /**
   * Remove ALL subscribers
   */
  unsubscribeAll() {
    try {
      this._listeners.clear();
    } catch (e) {
      this.debug("error", e, "unsubscribeAll error");
    }
  }
};
var _instance;
var _EventEmitterSingleton = class _EventEmitterSingleton extends EventEmitter {
  constructor(options) {
    super(options);
    if (__privateGet(_EventEmitterSingleton, _instance)) {
      return __privateGet(_EventEmitterSingleton, _instance);
    }
    __privateSet(_EventEmitterSingleton, _instance, this);
    return this;
  }
  /**
   * Destroy singleton reference and remove all subscribers
   */
  destroy() {
    try {
      this.unsubscribeAll();
      __privateSet(_EventEmitterSingleton, _instance, null);
    } catch (e) {
      this.debug("error", e, "destroy error");
    }
  }
};
_instance = new WeakMap();
__privateAdd(_EventEmitterSingleton, _instance, null);
var EventEmitterSingleton = _EventEmitterSingleton;
var src_default = {
  EventEmitterSingleton,
  EventEmitter
};
export {
  EventEmitter,
  EventEmitterSingleton,
  src_default as default
};
//# sourceMappingURL=index.mjs.map